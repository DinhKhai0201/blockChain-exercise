{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst protons = require('protons');\n\nconst proto = protons(require('./dag.proto.js'));\n\nconst resolver = require('./resolver');\n\nconst DAGLink = require('./dag-link');\n\nconst DAGNode = require('./dag-node');\n\nconst multihashing = require('multihashing-async');\n\nconst waterfall = require('async/waterfall');\n\nconst setImmediate = require('async/setImmediate');\n\nexports = module.exports;\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version] - CID version number. Defaults to zero if hashAlg == 'sha2-256'; otherwise, 1.\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\n\nfunction cid(dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  let version = options.version;\n\n  if (typeof version === 'undefined') {\n    version = hashAlg === 'sha2-256' ? 0 : 1;\n  }\n\n  waterfall([cb => {\n    if (Buffer.isBuffer(dagNode)) {\n      return cb(null, dagNode);\n    }\n\n    serialize(dagNode, cb);\n  }, (serialized, cb) => multihashing(serialized, hashAlg, cb), (mh, cb) => cb(null, new CID(version, resolver.multicodec, mh))], callback);\n}\n\nfunction serialize(node, callback) {\n  let serialized;\n  let data = node.data,\n      _node$links = node.links,\n      links = _node$links === void 0 ? [] : _node$links; // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n\n  if (!DAGNode.isDAGNode(node) && links) {\n    links = links.map(link => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n    });\n  }\n\n  try {\n    serialized = proto.PBNode.encode(toProtoBuf({\n      data,\n      links\n    }));\n  } catch (err) {\n    return callback(err);\n  }\n\n  callback(null, serialized);\n}\n\nfunction deserialize(buffer, callback) {\n  const pbn = proto.PBNode.decode(buffer);\n  const links = pbn.Links.map(link => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data;\n  setImmediate(() => callback(null, new DAGNode(data, links, buffer.length)));\n}\n\nfunction toProtoBuf(node) {\n  const pbn = {};\n\n  if (node.data && node.data.length > 0) {\n    pbn.Data = node.data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n\n  if (node.links && node.links.length > 0) {\n    pbn.Links = node.links.map(link => ({\n      Hash: link.cid.buffer,\n      Name: link.name,\n      Tsize: link.size\n    }));\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n}\n\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":null,"metadata":{},"sourceType":"script"}